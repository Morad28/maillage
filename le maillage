from __future__ import division 
import matplotlib.pyplot as plt 
def maillage_carre(n,m):
    X=[x/(n-1) for x in range(n)]
    Y=[y/(m-1) for y in range(m)]
    N=n*m
    NP=[]       #Va contenir les numéros associés aux points 
    i,j,k=1,1,2
    T=[]        #Va contenir les numéros des triangles associés à leurs points
    T_sup=[]
    T_inf=[]
    for y in Y:
        for x in X:
            NP=NP+[[i,(x,y)]]       #On assosie à chaque point un numéro
            i=i+1
    
    for l in range(1,N-n,n):        
        for i in range(l,l+n-1):
            T_sup=T_sup+[(i,i+n,i+n+1)]     #Comme on numérote les points de gauche à droite en partant du bas
            T_inf=T_inf+[(i,i+1,i+n+1)]     #On a une relation etre le triangle i et ses points, en distingant 
                                            #les triangles supérieurs et inférieurs
    for t in T_sup:
        T=T+[[j,t]]                         #On associe aux triangles leur numéro
        j=j+2
    for t in T_inf:
        T=T+[[k,t]]
        k=k+2
    T=sorted(T)
    
    for i in range(m):
        plt.plot([0,1],[i/(m-1),i/(m-1)],c="b")         #On construit le quadrillage du carré unité
    for i in range(n):
        plt.plot([i/(n-1),i/(n-1)],[0,1],c="b")
    plt.axis("equal")
    
    lt=len(T)
    for i in range(lt):
        p1,p2,p3=T[i][1]
        x1,x2,x3=NP[p1-1][1][0],NP[p2-1][1][0],NP[p3-1][1][0]       #On construit les triangles
        y1,y2,y3=NP[p1-1][1][1],NP[p2-1][1][1],NP[p3-1][1][1]
        plt.triplot([x1,x2,x3],[y1,y2,y3])
    plt.show()
    return(T)
    
def arretes(L):
    A=[]
    for p in range(len(L)):
        i,j,k=L[p][1]
        A=A+[[[i,j],[j,k],[k,i]]]
    return(A)

from random import *
import matplotlib.pyplot as plt
import numpy as np

def nuage(N,xmin,xmax,e):
    L=[np.array([xmin+(xmax-xmin)*random(),xmin+(xmax-xmin)*random()])]
    X=[]
    Y=[]
    j=0
    for j in range(N):
        x,y=xmin+(xmax-xmin)*random(),xmin+(xmax-xmin)*random()
        L.append(np.array([x,y]))
        X.append(x)
        Y.append(y)
        for i in range(len(L)-1):
            if np.linalg.norm(L[i]-L[-1])<e:
                L.pop()
                X.pop()
                Y.pop()
    plt.plot([xmin,xmax,xmax,xmin,xmin],[xmin,xmin,xmax,xmax,xmin])    
    plt.scatter(X,Y,c="r",s=10)
    plt.axis("equal")
    plt.show()
    
    
def point_dans_triangle(point,triangle):        #Test si un point est dans un triangle ou pas, et renvoie True si c'est le cas
    p1,p2,p3=triangle
    xa,xb,xc=p1[0],p2[0],p3[0]
    ya,yb,yc=p1[1],p2[1],p3[1]
    x,y=point[0],point[1]
    s1=(x-xa)*(y-yb)-(y-ya)*(x-xb)
    s2=(x-xb)*(y-yc)-(y-yb)*(x-xc)
    s3=(x-xc)*(y-ya)-(y-yc)*(x-xa)
    plt.plot([xa,xb,xc,xa],[ya,yb,yc,ya])
    plt.scatter(x,y)
    plt.show()
    if s1*s2>0 and s2*s3>0:
        return(True)
    else:
        return(False)

def trouver_triangle(point,T,NP):       #Parcours le maillage T pour trouver dans quel triangle est le point, NP sont les points associés à leurs coordonnées
    for triangle in T:
        i1,i2,i3=triangle
        p1,p2,p3=NP[i1-1][1],NP[i2-1][1],NP[i3-1][1]
        if point_dans_triangle(point,[p1,p2,p3])==True:
            return(triangle)

def de_Delaunay(T1,point):      #Permet de savoir si deux triangles sont de Delaunay 
    p1,p2,p3=T1
    x1,y1=p1
    x2,y2=p2
    x3,y3=p3
    A=(y2-y1)*(x3**2-x2**2+y3**2-y2**2)-(y3-y2)*(x2**2-x1**2+y2**2-y1**2)
    B=(y3-y2)*(x2-x1)-(y2-y1)*(x3-x2)
    if B!=0:
        Cx=(1/2)*(A/B)
        Cy=-(x2-x1)/(y2-y1)*Cx+(x2**2-x1**2+y2**2-y1**2)/(2*(y2-y1))
        R=np.linalg.norm(np.array([Cx,Cy])-np.array(p1))
        if np.linalg.norm(np.array(point)-np.array([Cx,Cy]))<R:
            return False
        else:
            return True 
